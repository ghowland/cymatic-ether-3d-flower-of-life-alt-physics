#!/usr/bin/env python3
"""
Cymatic Fly-Through  (pure NumPy, ~120 lines)
---------------------------------------------
Fly inside the 3-D hologram generated by the Master Loop.
WASD moves forward/back & turns; Q quits.
No external librariesâ€”just NumPy and terminal magic.
"""
import numpy as np
import time
import sys
import tty
import termios
import threading

# ---------- 1.  CONSTANTS  ---------------------------------------------
SIZE      = 32          # cubic lattice (kept small for speed)
DT        = 0.03        # Planck-tick
DAMP      = 0.02        # intrinsic damping
R_MAX     = 3.0         # congestion deletion threshold
NOISE     = 0.03        # thermal noise strength
TERM_W    = 80          # terminal width
TERM_H    = 24          # terminal height
FOV       = 70 * np.pi / 180
MAX_STEPS = SIZE * 2
ASCII     = np.array([' ', '.', '-', '~', '+', '*', '#', '@'], dtype='<U1')

# ---------- 2.  SUBSTRATE (k-space)  ----------------------------------
k = np.fft.fftfreq(SIZE)
kx, ky, kz = np.meshgrid(k, k, k, indexing='ij')
k_mag = np.sqrt(kx**2 + ky**2 + kz**2)
k_mag[0, 0, 0] = 1e-6
omega = 2 * np.pi * k_mag
field_k = np.zeros((SIZE, SIZE, SIZE), dtype=complex)

# seed two spectral packets
def packet(c, w, a):
    d2 = (kx - c[0])**2 + (ky - c[1])**2 + (kz - c[2])**2
    return a * np.exp(-d2 / (2 * w**2)) * np.exp(1j * np.random.uniform(0, 2*np.pi, d2.shape))

field_k += packet([0.1, 0.0, 0.0], 0.08, 20)
field_k += packet([-0.1, 0.0, 0.0], 0.08, 20)

# ---------- 3.  CAMERA STATE  -------------------------------------------
cam_pos   = np.array([SIZE//2, SIZE//2, SIZE//2], dtype=float)
cam_yaw   = 0.0
cam_pitch = 0.0
lock      = threading.Lock()

# ---------- 4.  MASTER LOOP THREAD  -----------------------------------
def master_loop():
    global field_k
    while True:
        with lock:
            # 1. evolve spectrum
            field_k *= np.exp(-1j * omega * DT - DAMP * DT)
            # 2. manifest
            field_x = np.abs(np.fft.ifftn(field_k))
            # 3. congestion filter
            if field_x.max() > R_MAX:
                dmg = np.fft.fftn((field_x > R_MAX).astype(float))
                field_k *= np.exp(-0.15 * np.abs(dmg))
            # 4. thermal noise
            field_k += (np.random.normal(0, NOISE, field_k.shape)
                        + 1j * np.random.normal(0, NOISE, field_k.shape))
        time.sleep(DT)

threading.Thread(target=master_loop, daemon=True).start()

# ---------- 5.  RAY-MARCH RENDER  ---------------------------------------
def render():
    with lock:
        vol = np.abs(np.fft.ifftn(field_k))
    # build ray directions
    aspect = TERM_H / TERM_W
    x = np.linspace(-np.tan(FOV/2), np.tan(FOV/2), TERM_W)
    y = np.linspace(-np.tan(FOV/2)*aspect, np.tan(FOV/2)*aspect, TERM_H)
    xx, yy = np.meshgrid(x, y)
    zz = np.ones_like(xx)
    ray_dir = np.stack([xx, yy, zz], axis=-1)
    ray_dir /= np.linalg.norm(ray_dir, axis=-1, keepdims=True)
    # rotate by yaw/pitch
    cy, sy = np.cos(cam_yaw), np.sin(cam_yaw)
    cp, sp = np.cos(cam_pitch), np.sin(cam_pitch)
    rot = np.array([[cy, 0, sy], [sp*sy, cp, -sp*cy], [-cp*sy, sp, cp*cy]])
    ray_dir = ray_dir @ rot.T
    # march
    hit = np.zeros((TERM_H, TERM_W))
    for step in range(1, MAX_STEPS+1):
        pos = cam_pos + step * ray_dir
        inside = (pos >= 0) & (pos < SIZE)
        idx = np.clip(pos.astype(int), 0, SIZE-1)
        val = np.where(inside.all(axis=-1),
                        vol[idx[:,:,0], idx[:,:,1], idx[:,:,2]], 0)
        hit = np.maximum(hit, val)
    # map to ASCII
    hit /= hit.max() + 1e-9
    lines = [''.join(ASCII[np.minimum(7, (hit[row]*8).astype(int))])
             for row in range(TERM_H)]
    print('\033[H' + '\n'.join(lines))

# ---------- 6.  INPUT HANDLER  -----------------------------------------
def getch():
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        return sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)

def input_loop():
    global cam_yaw, cam_pitch, cam_pos
    while True:
        ch = getch()
        if ch == 'q': break
        if ch == 'w': cam_pos[2] -= 1
        if ch == 's': cam_pos[2] += 1
        if ch == 'a': cam_yaw   -= 0.15
        if ch == 'd': cam_yaw   += 0.15
        cam_pitch = np.clip(cam_pitch, -np.pi/2, np.pi/2)

threading.Thread(target=input_loop, daemon=True).start()

# ---------- 7.  MAIN  -------------------------------------------------
print('\033[2J\033[H', end='')
print("WASD move forward/back & turn | Q to quit")
threading.Thread(target=input_loop, daemon=True).start()
while True:
    render()
    time.sleep(0.04)

    